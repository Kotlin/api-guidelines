<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <meta charset="UTF-8">   <meta name="built-on" content="${builtOn}">   <title>Backward compatibilityâ€”API guidelines</title><script id="virtual-toc-data" type="application/json">[{"id":"backward-compatibility-definition","level":0,"title":"Backward compatibility definition","anchor":"#backward-compatibility-definition"},{"id":"read-more-about-compatibility-types","level":1,"title":"Read more about compatibility types","anchor":"#read-more-about-compatibility-types"},{"id":"don-t-do-recommendations","level":0,"title":"\"Don\u0027t do\" recommendations","anchor":"#don-t-do-recommendations"},{"id":"don-t-add-arguments-to-existing-api-functions","level":1,"title":"Don\u0027t add arguments to existing API functions","anchor":"#don-t-add-arguments-to-existing-api-functions"},{"id":"don-t-use-data-classes-in-api","level":1,"title":"Don\u0027t use data classes in API","anchor":"#don-t-use-data-classes-in-api"},{"id":"don-t-make-return-types-narrower","level":1,"title":"Don\u0027t make return types narrower","anchor":"#don-t-make-return-types-narrower"},{"id":"the-publishedapi-annotation","level":0,"title":"The @PublishedApi annotation","anchor":"#the-publishedapi-annotation"},{"id":"the-requiresoptin-annotation","level":0,"title":"The @RequiresOptIn annotation","anchor":"#the-requiresoptin-annotation"},{"id":"explicit-api-mode","level":0,"title":"Explicit API mode","anchor":"#explicit-api-mode"},{"id":"tools-to-enforce-backward-compatibility","level":0,"title":"Tools to enforce backward compatibility","anchor":"#tools-to-enforce-backward-compatibility"},{"id":"binary-compatibility-validator","level":1,"title":"Binary compatibility validator","anchor":"#binary-compatibility-validator"},{"id":"japicmp","level":1,"title":"japicmp","anchor":"#japicmp"}]</script>     <link href="api-guidelines/app/app.css%3F_ijt=lfaskikimisqhp7sdvdbgm8l0a.css" rel="stylesheet">   <link rel="shortcut icon" href="https://resources.jetbrains.com/storage/ui/favicons/favicon.ico" type="image/x-icon" sizes="16x16 32x32"/><link rel="apple-touch-icon" sizes="57x57" href="https://resources.jetbrains.com/storage/ui/favicons/apple-touch-icon-57x57.png"/><link rel="apple-touch-icon" sizes="60x60" href="https://resources.jetbrains.com/storage/ui/favicons/apple-touch-icon-60x60.png"/><link rel="apple-touch-icon" sizes="72x72" href="https://resources.jetbrains.com/storage/ui/favicons/apple-touch-icon-72x72.png"/><link rel="apple-touch-icon" sizes="76x76" href="https://resources.jetbrains.com/storage/ui/favicons/apple-touch-icon-76x76.png"/><link rel="apple-touch-icon" sizes="114x114" href="https://resources.jetbrains.com/storage/ui/favicons/apple-touch-icon-114x114.png"/><link rel="apple-touch-icon" sizes="120x120" href="https://resources.jetbrains.com/storage/ui/favicons/apple-touch-icon-120x120.png"/><link rel="apple-touch-icon" sizes="144x144" href="https://resources.jetbrains.com/storage/ui/favicons/apple-touch-icon-144x144.png"/><link rel="apple-touch-icon" sizes="152x152" href="https://resources.jetbrains.com/storage/ui/favicons/apple-touch-icon-152x152.png"/><link rel="apple-touch-icon" sizes="180x180" href="https://resources.jetbrains.com/storage/ui/favicons/apple-touch-icon-180x180.png"/><link rel="mask-icon" href="https://resources.jetbrains.com/storage/ui/favicons/apple-mask-icon.svg" color="black"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>  <meta name="image" content="${ogMetaImage}"><!-- Open Graph --><meta property="og:title" content="Backward compatibility - Help | API guidelines"/><meta property="og:description" content=""/><meta property="og:image" content="${ogMetaImage}"/><meta property="og:site_name" content="API guidelines Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="${ogUrl}"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="${ogTwitter}"><meta name="twitter:title" content="Backward compatibility - Help | API guidelines"><meta name="twitter:description" content=""><meta name="twitter:creator" content="${ogTwitter}"><meta name="twitter:image:src" content="${ogMetaImage}"><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "${ogUrl}#webpage", "url": "${ogUrl}", "name": "Backward compatibility - Help | API guidelines", "description": "", "image": "${ogMetaImage}", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "${ogUrlRoot}#website", "url": "${ogUrlRoot}", "name": "API guidelines Help" }</script><!-- End Schema.org --></head>    <body data-id="jvm-api-guidelines-backward-compatibility" data-main-title="Backward compatibility" data-article-props="{&quot;microFormat&quot;:[],&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs=""  data-edit-url="https://github.com/Kotlin/api-guidelines/edit/main/docs/topics/jvm-api-guidelines-backward-compatibility.md"  >  <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>API guidelines  Help</h3><div class="shortcuts-switcher"><label for="switch-shortcuts">Keymap:</label><select class="select _shortcuts" height="1" id="switch-shortcuts">      </select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="jvm-api-guidelines-backward-compatibility" id="jvm-api-guidelines-backward-compatibility.md"  >Backward compatibility</h1><p id="22a5" >This chapter contains considerations about <a href="jvm-api-guidelines-backward-compatibility.html#backward-compatibility-definition" id="22a9"  >backward compatibility</a>. Here are the &quot;don't do&quot; recommendations:</p> <ul class="list _ul" id="22af"   ><li class="list__item" id="22b3" ><a href="jvm-api-guidelines-backward-compatibility.html#don-t-add-arguments-to-existing-api-functions" id="22b7"  >Don't add arguments to existing API functions</a></li> <li class="list__item" id="22bd" ><a href="jvm-api-guidelines-backward-compatibility.html#don-t-use-data-classes-in-api" id="22c1"  >Don't use data classes in API</a></li> <li class="list__item" id="22c7" ><a href="jvm-api-guidelines-backward-compatibility.html#don-t-make-return-types-narrower" id="22cb"  >Don't make return types narrower</a></li></ul> <p id="22d1" >Consider using:</p> <ul class="list _ul" id="22d5"   ><li class="list__item" id="22d9" ><a href="jvm-api-guidelines-backward-compatibility.html#the-publishedapi-annotation" id="22dd"  >@PublishedApi annotation</a></li> <li class="list__item" id="22e3" ><a href="jvm-api-guidelines-backward-compatibility.html#the-requiresoptin-annotation" id="22e7"  >@RequiresOptIn annotation</a></li> <li class="list__item" id="22ed" ><a href="jvm-api-guidelines-backward-compatibility.html#explicit-api-mode" id="22f1"  >Explicit API mode</a></li></ul> <p id="22f7" >Learn about <a href="jvm-api-guidelines-backward-compatibility.html#tools-to-enforce-backward-compatibility" id="22fb"  >tools to enforce backward compatibility</a>.</p> <section class="chapter" >  <h2 id="backward-compatibility-definition" data-toc="jvm-api-guidelines-backward-compatibility#backward-compatibility-definition" >Backward compatibility definition</h2><p id="2306" >One of the cornerstones of a good API is backward compatibility. Backward-compatible code allows clients of newer API versions to use the same API code that they used with an older API version. This section describes the main points you should think about to make your API backward compatible.</p> <p id="230a" >There are at least three types of compatibility when talking about APIs:</p> <ul class="list _ul" id="230e"   ><li class="list__item" id="2312" ><p>Source</p></li> <li class="list__item" id="2316" ><p>Behavioral</p></li> <li class="list__item" id="231a" ><p>Binary</p></li></ul> <section class="chapter" >   <div class="collapse"><div class="collapse__title" ><h3 id="read-more-about-compatibility-types" data-toc="jvm-api-guidelines-backward-compatibility#read-more-about-compatibility-types" >Read more about compatibility types</h3></div><div class="collapse__content"><p id="2324" >You can count versions of a library as  <b id="2328" class=""  >source-compatible</b> when you're sure that your client's application will recompile correctly against a newer version of your library. Usually, it's difficult to implement and check this automatically unless the changes are trivial. In any API, there are always corner cases when source compatibility might be broken by a particular change.</p> <p id="232c" ><b id="2330" class=""  >Behavioral compatibility</b> ensures that any new code does not change the semantics of the original code behavior, apart from fixing bugs.</p> <p id="2334" >A <b id="2338" class=""  >binary backward-compatible</b> version of a library can replace a previously compiled version of the library. Any software that was compiled against the previous version of the library should continue to work correctly.</p> <p id="233c" >It's possible to break binary compatibility without breaking source compatibility and to break source compatibility without breaking binary compatibility.</p> <p id="2340" >Some principles of keeping binary backward compatibility are obvious: don't just remove parts of a public API, instead, <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-deprecated/" data-external="true" id="2344" rel="noopener noreferrer" >deprecate</a> them. The following sections contain less well-known principles.</p></div></div>  </section>  </section><section class="chapter" >  <h2 id="don-t-do-recommendations" data-toc="jvm-api-guidelines-backward-compatibility#don-t-do-recommendations" >&quot;Don't do&quot; recommendations</h2><section class="chapter" >  <h3 id="don-t-add-arguments-to-existing-api-functions" data-toc="jvm-api-guidelines-backward-compatibility#don-t-add-arguments-to-existing-api-functions" >Don't add arguments to existing API functions</h3><p id="2354" >Adding non-default arguments to a public API is a breaking change because the existing code won't have enough information to call the updated methods. Adding even <a href="https://kotlinlang.org/docs/functions.html#default-arguments" data-external="true" id="2358" rel="noopener noreferrer" >default arguments</a> might also break your users' code.</p> <p id="235e" >Breaking backward compatibility is shown below in an example of two classes: <code class="code " id="2362"  >lib.kt</code> representing a &quot;library&quot;, <code class="code " id="2366"  >client.kt</code> representing some &quot;client&quot; of this &quot;library&quot;. This construct for libraries and their clients is common in real-world applications. In this example, the &quot;library&quot; has one function that computes the fifth member of the Fibonacci sequence. The file <code class="code " id="236a"  >lib.kt</code> contains:</p> <div class="code-block" data-lang="kotlin" id="2372"       >  fun fib() = &hellip; // Returns the fifth element
  </div> <p id="2377" >Let's call this function from another file, <code class="code " id="237b"  >client.kt</code>:</p> <div class="code-block" data-lang="kotlin" id="2383"       >  fun main() {
    println(fib()) // Returns 3
}
  </div> <p id="2388" >Let's compile classes:</p> <div class="code-block" data-lang="none" id="2390"      data-disable-link-processing="true" >  kotlinc lib.kt client.kt 
  </div> <p id="2395" >The compilation results in two files: <code class="code " id="2399"  >LibKt.class</code> and <code class="code " id="239d"  >ClientKt.class</code>.</p> <p id="23a1" >Let's call the client to make sure that it works:</p> <div class="code-block" data-lang="none" id="23a9"      data-disable-link-processing="true" >  $ kotlin ClientKt.class
3
  </div> <p id="23ae" >The design is far from perfect and hardcoded for learning purposes. It predefines what element of the sequence you want to obtain, which is incorrect and doesn't follow clean code principles. Let's rewrite it preserving the same default behavior: returning the fifth element by default. But now it will be possible to provide an element number that you want to get.</p> <p id="23b2" ><code class="code " id="23b6"  >lib.kt</code>:</p> <div class="code-block" data-lang="kotlin" id="23be"       >  fun fib(numberOfElement: Int = 5) = &hellip; // Returns requested member
  </div> <p id="23c3" >Let's recompile only the &quot;library&quot;:  <code class="code " id="23c7"  >kotlinc lib.kt</code>.</p> <p id="23cb" >Let's run the &quot;client&quot;:</p> <div class="code-block" data-lang="none" id="23d3"      data-disable-link-processing="true" >  $ kotlin ClientKt.class
  </div> <p id="23d8" >The result is:</p> <div class="code-block" data-lang="none" id="23e0"      data-disable-link-processing="true" >  Exception in thread &quot;main&quot; java.lang.NoSuchMethodError: 'int LibKt.fib()'
       at LibKt.main(fib.kt:2)
       at LibKt.main(fib.kt)
       &hellip;
  </div> <p id="23e5" >There is a <code class="code " id="23e9"  >NoSuchMethodError</code> because the signature of the <code class="code " id="23ed"  >fib()</code> function changed after compilation.</p> <p id="23f1" >If you recompile <code class="code " id="23f5"  >client.kt</code>, it will work again because it will be aware of the new signature. In this example, <b id="23f9" class=""  >binary compatibility was broken while preserving source compatibility</b>.</p> <section class="chapter" >   <div class="collapse"><div class="collapse__title" ><h4 id="learn-more-about-what-happened-with-the-help-of-decompilation" data-toc="jvm-api-guidelines-backward-compatibility#learn-more-about-what-happened-with-the-help-of-decompilation" >Learn more about what happened with the help of decompilation</h4></div><div class="collapse__content"><aside data-type="note" class="prompt" data-title="" id="2403" ><p id="2408" >This explanation is JVM-specific.</p></aside> <p id="240c" >Let's call <a href="https://docs.oracle.com/en/java/javase/20/docs/specs/man/javap.html" data-external="true" id="2410" rel="noopener noreferrer" ><code class="code " id="2416"  >javap</code></a> on the <code class="code " id="241a"  >LibKt</code> class before the changes:</p> <div class="code-block" data-lang="none" id="2422"      data-disable-link-processing="true" >  &#10095; javap FiLibKtbKt
Compiled from &quot;lib.kt&quot;
public final class LibKt {
 public static final int fib();
}
  </div> <p id="2427" >And after the changes:</p> <div class="code-block" data-lang="none" id="242f"      data-disable-link-processing="true" >  &#10095; javap LibKt
Compiled from &quot;lib.kt&quot;
public final class LibKt {
 public static final int fib(int);
 public static int fib$default(int, int, java.lang.Object);
}
  </div> <p id="2434" >The method with signature <code class="code " id="2438"  >public static final int fib()</code> was replaced with a new method with signature <code class="code " id="243c"  >public static final int fib(int)</code> . At the same time, a proxy method <code class="code " id="2440"  >fib$default</code> delegates the execution to <code class="code " id="2444"  >fib(int)</code>. For JVM, it's possible to work around this: you need to add a <a href="https://kotlinlang.org/docs/java-to-kotlin-interop.html#overloads-generation" data-external="true" id="2448" rel="noopener noreferrer" ><code class="code " id="244e"  >@JvmOverloads</code></a> annotation. For multiplatform projects, there is unfortunately no workaround.</p></div></div>  </section>  </section><section class="chapter" >  <h3 id="don-t-use-data-classes-in-api" data-toc="jvm-api-guidelines-backward-compatibility#don-t-use-data-classes-in-api" >Don't use data classes in API</h3><p id="2457" ><a href="https://kotlinlang.org/docs/data-classes.html" data-external="true" id="245b" rel="noopener noreferrer" >Data classes</a> are tempting to use because they are short, concise, and have some functionality out of the box. However, due to some specifics of how data classes work, it's better not to use them in library APIs. Almost any change makes the API not backward compatible.</p> <p id="2461" >Usually, it's hard to predict how you will need to change a class over time. Even if today you think that it's self-contained, there is no way to be sure that your needs won't change in the future. So, all the issues with data classes only exist when you decide to change such a class.</p> <p id="2465" >Firstly, the considerations from the previous section <a href="jvm-api-guidelines-backward-compatibility.html#don-t-add-arguments-to-existing-api-functions" id="2469"  >Don't add arguments to existing API functions</a> also apply to the constructor as it is also a method. Secondly, even if you add secondary constructors, it won't solve the compatibility problem. Let's look at the following data class:</p> <div class="code-block" data-lang="kotlin" id="2473"       >  data class User(
    val name: String,
    val email: String
)
  </div> <p id="2478" >For example, over some time, you understand that users should go through an activation procedure, so you want to add a new field, &quot;active&quot; with a default value equal to &quot;true&quot;. This new field should allow the existing code to work mostly without changes.</p> <p id="247c" >As it was already discussed in the <a href="jvm-api-guidelines-backward-compatibility.html#don-t-add-arguments-to-existing-api-functions" id="2480"  >section above</a>, you can't just add a new field like this:</p> <div class="code-block" data-lang="kotlin" id="248a"       >  data class User(
    val name: String,
    val email: String,
    val active: Boolean = true
)
  </div> <p id="248f" >Because this change is <b id="2493" class=""  >not binary compatible</b>.</p> <p id="2497" >Let's add a new constructor that accepts only two arguments and calls the primary constructor with a third default argument:</p> <div class="code-block" data-lang="kotlin" id="249f"       >  data class User(
    val name: String,
    val email: String,
    val active: Boolean = true
) {
    constructor(name: String, email: String) :
            this(name, email, active = true)
}
  </div> <p id="24a4" >This time there are two constructors, and a signature of one of them matches the constructor of the class before the change:</p> <div class="code-block" data-lang="java" id="24ac"       >  public User(java.lang.String, java.lang.String);
  </div> <p id="24b1" >But the issue is not with the constructor, it's with the <code class="code " id="24b5"  >copy</code> function. Its signature has changed from:</p> <div class="code-block" data-lang="java" id="24bd"       >  public final User copy(java.lang.String, java.lang.String);
  </div> <p id="24c2" >To:</p> <div class="code-block" data-lang="java" id="24ca"       >  public final User copy(java.lang.String, java.lang.String, boolean);
  </div> <p id="24cf" >And it has made the code <b id="24d3" class=""  >binary incompatible</b>.</p> <p id="24d7" >Of course, it's possible just to add a property inside the data class, but it removes all the bonuses of it being a data class. Therefore, it's better not to use data classes in your API because almost any change in them breaks source, binary, or behavioral compatibility.</p> <p id="24db" >If you have to use a data class for whatever reason, you have to override the constructor and the <code class="code " id="24df"  >copy()</code> method. In addition, if you add a field into the class's body, you have to override the <code class="code " id="24e3"  >hashCode()</code> and <code class="code " id="24e7"  >equals()</code> methods.</p> <aside data-type="warning" class="prompt" data-title="" id="24eb"><p id="24f0" >It's always an incompatible change to swap the order of arguments because of <code class="code " id="24f4"  >componentX()</code> methods. It breaks source compatibility and probably will break binary compatibility too.</p></aside>  </section><section class="chapter" >  <h3 id="don-t-make-return-types-narrower" data-toc="jvm-api-guidelines-backward-compatibility#don-t-make-return-types-narrower" >Don't make return types narrower</h3><p id="24fd" >Sometimes, especially when you don't use <a href="https://kotlinlang.org/docs/whatsnew14.html#explicit-api-mode-for-library-authors" data-external="true" id="2501" rel="noopener noreferrer" >explicit API mode</a>, a return type declaration can change implicitly. But even if it's not the case, you might want to narrow the signature. For example, sometimes you realize that you need index access to the elements of your collection and want to change the return type from <code class="code " id="2507"  >Collection</code> to <code class="code " id="250b"  >RandomAccess</code>. This section describes why it is a bad idea for a library author to make such a change.</p> <p id="250f" >Consider a library function in the <code class="code " id="2513"  >library.kt</code> file:</p> <div class="code-block" data-lang="kotlin" id="251b"       >  public fun x(): Number = 3
  </div> <p id="2520" >And an example of its use in the <code class="code " id="2524"  >client.kt</code> file:</p> <div class="code-block" data-lang="kotlin" id="252c"       >  fun main() {
    println(x()) // Prints 3
}
  </div> <p id="2531" >Let's compile it with <code class="code " id="2535"  >kotlinc library.kt client.kt</code> and make sure that it works:</p> <div class="code-block" data-lang="none" id="253d"      data-disable-link-processing="true" >  $ kotlin ClientKt
3
  </div> <p id="2542" >Let's change the return type of the &quot;library&quot; function <code class="code " id="2546"  >x()</code> from <code class="code " id="254a"  >Number</code> to <code class="code " id="254e"  >Int</code>:</p> <div class="code-block" data-lang="kotlin" id="2556"       >  fun x(): Int = 3
  </div> <p id="255b" >And recompile only the client: <code class="code " id="255f"  >kotlinc client.kt</code>. <code class="code " id="2563"  >ClientKt</code> doesn't work as expected anymore. It doesn't print <code class="code " id="2567"  >3</code> and throws an exception instead:</p> <div class="code-block" data-lang="none" id="256f"      data-disable-link-processing="true" >  Exception in thread &quot;main&quot; java.lang.NoSuchMethodError: 'java.lang.Number Library.x()'
    	at ClientKt.main(call.kt:2)
    	at ClientKt.main(call.kt)
    	&hellip;
  </div> <p id="2574" >This happens because of the following line in bytecode:</p> <div class="code-block" data-lang="none" id="257c"      data-disable-link-processing="true" >  0: invokestatic  #12 // Method Library.x:()Ljava/lang/Number;
  </div> <p id="2581" >This line means that you call the static method <code class="code " id="2585"  >x()</code> returning the type <code class="code " id="2589"  >Number</code>. But there is no longer such a method &ndash; <b id="258d" class=""  >binary compatibility has been violated</b>.</p>  </section>  </section><section class="chapter" >  <h2 id="the-publishedapi-annotation" data-toc="jvm-api-guidelines-backward-compatibility#the-publishedapi-annotation" >The @PublishedApi annotation</h2><p id="2596" >Sometimes, you might need to use a part of your internal API to implement <a href="https://kotlinlang.org/docs/inline-functions.html" data-external="true" id="259a" rel="noopener noreferrer" >inline functions</a>. You can do this with the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-published-api" data-external="true" id="25a0" rel="noopener noreferrer" ><code class="code " id="25a6"  >@PublishedApi</code></a> annotation. You should treat parts of code annotated with <code class="code " id="25aa"  >@PublishedApi</code> as parts of public API, and, therefore, you should be careful about their backward compatibility.</p>  </section><section class="chapter" >  <h2 id="the-requiresoptin-annotation" data-toc="jvm-api-guidelines-backward-compatibility#the-requiresoptin-annotation" >The @RequiresOptIn annotation</h2><p id="25b3" >Sometimes, you might want to experiment with your API. In Kotlin, there is a nice way to define that some API is unstable &ndash; use the <a href="https://kotlinlang.org/docs/opt-in-requirements.html#require-opt-in-for-api" data-external="true" id="25b7" rel="noopener noreferrer" ><code class="code " id="25bd"  >@RequiresOptIn</code> annotation</a>. However, be aware of the following:</p> <ol class="list _decimal" id="25c1"   ><li class="list__item" id="25c5" ><p>If you haven't changed something for a long time and it's stable, you should reconsider using the <code class="code " id="25c9"  >@RequiresOptIn</code> annotation.</p></li> <li class="list__item" id="25cd" ><p>You may use the <code class="code " id="25d1"  >@RequiresOptIn</code> annotation to define different guarantees to different parts of the API: Preview, Experimental, Internal, Delicate, or Alpha, Beta, RC.</p></li> <li class="list__item" id="25d5" ><p>You should explicitly define what each <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-requires-opt-in/-level/" data-external="true" id="25d9" rel="noopener noreferrer" >level</a> means, write <a href="https://kotlinlang.org/docs/kotlin-doc.html" data-external="true" id="25df" rel="noopener noreferrer" >KDoc</a> comments, and add a warning message.</p></li></ol> <p id="25e5" >If you depend on an API requiring opt-in, don't use the <code class="code " id="25e9"  >@OptIn</code> annotation. Instead, use the <code class="code " id="25ed"  >@RequiresOptIn</code> annotation so that your user is able to consciously choose what API they want to use and what not.</p> <p id="25f1" >Another example of <code class="code " id="25f5"  >@RequiresOptIn</code> is when you want to explicitly warn users about the usage of some API. For example, if you maintain a library that utilizes Kotlin reflection, you can annotate classes in this library with <code class="code " id="25f9"  >@OptIn(RequiresFullKotlinReflection::class)</code>.</p>  </section><section class="chapter" >  <h2 id="explicit-api-mode" data-toc="jvm-api-guidelines-backward-compatibility#explicit-api-mode" >Explicit API mode</h2><p id="2602" >You should try to keep your API as transparent as possible. To force the API to be transparent, use the <a href="https://kotlinlang.org/docs/whatsnew14.html#explicit-api-mode-for-library-authors" data-external="true" id="2606" rel="noopener noreferrer" >explicit API mode</a>.</p> <p id="260c" >Kotlin gives you vast freedom in how you can write code. It is possible not to define types, omit visibility declarations, or omit documentation for something. The explicit API mode forces you as a developer to make implicit things explicit. By the link above, you can find out how to enable it. Let's try to understand why you might need it:</p> <ol class="list _decimal" id="2610"   ><li class="list__item" id="2614" ><p id="2618" >Without an explicit API, it's easier to break backward compatibility:</p> <div class="code-block" data-lang="kotlin" id="2620"       >  // version 1
fun getToken() = 1

// version 1.1
fun getToken() = &quot;1&quot;
  </div> <p id="2625" >The return type of <code class="code " id="2629"  >getToken()</code> changes, but you don't even need to update the signature for it to break users' code &mdash; they expect to get <code class="code " id="262d"  >Int</code>, but they get <code class="code " id="2631"  >String</code>.</p></li> <li class="list__item" id="2635" ><p id="2639" >The same applies to visibility. If the <code class="code " id="263d"  >getToken()</code> function is <code class="code " id="2641"  >private</code>, then backward compatibility is not broken. But without an explicit visibility declaration, it's unclear whether an API user should be able to access it. If they should be able to, it should be declared as <code class="code " id="2645"  >public</code> and documented; in this case, the change breaks backward compatibility. If not, it should be defined as <code class="code " id="2649"  >private</code> or <code class="code " id="264d"  >internal</code>, and this change won't be breaking.</p></li></ol>  </section><section class="chapter" >  <h2 id="tools-to-enforce-backward-compatibility" data-toc="jvm-api-guidelines-backward-compatibility#tools-to-enforce-backward-compatibility" >Tools to enforce backward compatibility</h2><p id="2656" >Backward compatibility is a crucial aspect of software development, as it ensures that new versions of a library or framework can be used with existing code without causing any issues. Maintaining backward compatibility can be a difficult and time-consuming task, especially when dealing with a large codebase or complex APIs. It's hard to control it manually, and developers often have to rely on testing and manual inspection to ensure that changes do not break existing code. To address this issue, JetBrains created the <a href="jvm-api-guidelines-backward-compatibility.html#binary-compatibility-validator" id="265a"  >Binary compatibility validator</a>, and there is also another solution: <a href="jvm-api-guidelines-backward-compatibility.html#japicmp" id="2660"  >japicmp</a>.</p> <aside data-type="note" class="prompt" data-title="" id="2666" ><p id="266b" >At the moment, both work only for JVM.</p></aside> <p id="266f" >Both solutions have their advantages and disadvantages. japicmp works for any JVM language, and it's both a CLI tool and a build system plugin. However, it requires having both old and new applications packaged as JAR files. It's not that easy to use when you don't have access to older builds of your library. Also, japicmp gives information on changes in Kotlin metadata, which you may not need (because a metadata format is not specified and is considered to be used only for Kotlin internal usage).</p> <p id="2673" >The Binary compatibility validator works only as a Gradle plugin, and it is on the <a href="https://kotlinlang.org/docs/components-stability.html#stability-levels-explained" data-external="true" id="2677" rel="noopener noreferrer" >Alpha stability level</a>. It doesn't need access to JAR files. It only needs specific dumps of the previous API and the current API. It's capable of collecting these dumps itself. Learn more about these tools below.</p> <section class="chapter" >  <h3 id="binary-compatibility-validator" data-toc="jvm-api-guidelines-backward-compatibility#binary-compatibility-validator" >Binary compatibility validator</h3><p id="2682" >The <a href="https://github.com/Kotlin/binary-compatibility-validator" data-external="true" id="2686" rel="noopener noreferrer" >Binary compatibility validator</a> is a tool that helps you to ensure the backward compatibility of your libraries and frameworks by automatically detecting and reporting any breaking changes in the API. The tool analyzes the library's bytecode before and after you made changes and compares the two versions to identify any changes that may break existing code. This makes it easy to detect and fix any issues before they become a problem for your users.</p> <p id="268c" >It can save a significant amount of time and effort that you would otherwise spend on manual testing and inspection. It can also help to prevent issues that may arise due to breaking changes in the API. This can ultimately lead to a better user experience, as users will be able to rely on the stability and compatibility of the library or framework.</p>  </section><section class="chapter" >  <h3 id="japicmp" data-toc="jvm-api-guidelines-backward-compatibility#japicmp" >japicmp</h3><p id="2695" >If you target only JVM as your platform, you can also use <a href="https://siom79.github.io/japicmp/" data-external="true" id="2699" rel="noopener noreferrer" >japicmp</a>. japicmp operates on a different level to the Binary compatibility validator: it compares two jar files &ndash;old and new&ndash; and reports incompatibilities between them.</p> <p id="269f" >Be aware that japicmp reports not only incompatibilities but also changes that should not affect a user in any way. For example, consider this code:</p> <div class="code-block" data-lang="kotlin" id="26a7"       >  class Calculator {
    fun add(a: Int, b: Int): Int {
        return a + b
    }

    fun multiply(a: Int, b: Int): Int {
        return a * b
    }
}
  </div> <p id="26ac" >If you add a new method without breaking the compatibility like this:</p> <div class="code-block" data-lang="kotlin" id="26b4"       >  class Calculator {
    fun add(a: Int, b: Int): Int {
        return a + b
    }

    fun multiply(a: Int, b: Int): Int {
        return a * b
    }

    fun divide(a: Int, b: Int): Int {
        return a / b
    }
}
  </div> <p id="26b9" >japicmp reports the following change:</p> <p id="26bd" ><figure  class=" " id="26c1"><img alt="Output of japicmp checking compatibility" title="Output of japicmp checking compatibility" src="api-guidelines/japicmp-calculator-output.png%3F_ijt=lfaskikimisqhp7sdvdbgm8l0a" id="26c1" class="  "  width="700" height="178" /></figure></p> <p id="26c8" >It's just a change in the <code class="code " id="26cc"  >@Metadata</code> annotation, which isn't very interesting, but japicmp is JVM-language agnostic and has to report everything it sees.</p>  </section>  </section><div class="last-modified"> Last modified: 10 April 2023</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">   </div></article><div id="disqus_thread"></div></div></section></main></div>  <script src="api-guidelines/app/app.js%3F_ijt=lfaskikimisqhp7sdvdbgm8l0a"></script></body></html>